## C/C++的过程

[一个程序从源代码到可执行程序的过程](https://blog.csdn.net/qq_39755395/article/details/78293733)

一个源程序到一个可执行程序的过程：预编译、编译、汇编、链接。
其中，编译是主要部分，其中又分为六个部分：词法分析、语法分析、语义分析、中间代码生成、目标代码生成和优化。

- 预编译：#的宏替换等
- 编译
  - 词法分析：识别一个个单词
  - 语法分析：生成语法树，运算符的优先级、还有括号匹配等
  - 语义分析：判断表达式是否有意义。类型判断，类型匹配等
  - 生成代码：生成中间汇编，优化
- 汇编：生成机器码
- 链接：多模块链接



## 什么是可执行文件

机器码，可执行指令的集合



## Java的过程

分为编译过程和解释过程

### 编译过程

编译过程和C/C++类似，但是目标是生成JVM字节码。示意图片如下：

![img](https://img-blog.csdn.net/20170205113216819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnV6aG9uZ21pbjA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### 解释过程

JVM对字节码的执行方法有两种：

- 解释执行。有解释器对字节码解释执行（第二行）
- 编译执行。即时编译器（JIT）产生本地执行代码（第三行）

![0.png](http://reimuwang.org/images/blog_pic/JVM/%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/0.png)

> ### 基于栈的指令集与基于寄存器的指令集
>
> 如1+1，如果是基于栈：
>
> ```
> iconst_1    // 将1压入操作数栈
> iconst_1    // 将1压入操作数栈
> iadd    // 弹出操作数栈栈顶的两个int型元素求和后再将int型结果压回操作数栈
> istore_0    // 将操作数栈栈顶的int型元素弹出并存入局部变量表索引为0的Slot中
> ```
>
> 如果是基于寄存器：
>
> ```
> mov eax, 1    // 将eax寄存器的值设为1
> add eax, 1    // 将eax寄存器中的值加1并存回eax寄存器
> ```
>
> 明显看出区别。但是基于寄存器的往往会依赖于硬件，每当硬件更好都需要重新编译。基于栈的话更为抽象，可以将更多的工作交给虚拟机，而这也当然以一些时间为代价。
>
> 栈架构比寄存器架构慢，上文给出的原因其实只是次要原因，更重要的是，栈并不是物理机实际提供的一个硬件，它只是存在于内存中的一个抽象概念。**寄存器是距离CPU最近的存储单元**，其次是缓存，然后才是内存。**使用栈意味着指令中的那些出栈入栈其实都是CPU在与内存交互**，尽管部分热点数据会进入缓存甚至寄存器，然而这无法从本质上解决问题，毕竟栈的主体依然还在内存中，而且频繁的内存-缓存-寄存器间数据的流动本身就是一项开销，因此栈架构比寄存器架构要慢很多。

