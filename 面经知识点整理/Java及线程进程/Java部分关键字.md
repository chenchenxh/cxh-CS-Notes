## native

https://blog.csdn.net/wike163/article/details/6635321

#### 原理

简单地讲，一个Native Method就是一个java调用非java代码的接口。**一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。**这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的函数。

- native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。

- 如果一个含有本地方法的类被**继承，子类会继承这个本地方法并且可以用java语言重写这个方法**（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写。

#### 作用

1. java和外部环境交互
2. 和操作系统交互。 JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。

#### 加载

​	我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。
 	如果一个方法描述符内有native，这个描述符块将有一个**指向该方法的实现的指针**。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。**当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。**

## static

用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块

- 静态方法
- 静态变量
- 静态代码块（编译时运行，按类中出现顺序执行）

## final

- 类。说明这个类不能被继承

- 方法。《Java编程思想》：　“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“ **类的private方法会隐式地被指定为final方法。**

- 变量

  1. 变量不可变
  2. final变量在编译期间会像C++的宏变量一样，比如会在String常量池这类看到区别：

  ```java
  public class Test {
      public static void main(String[] args)  {
          String a = "hello2"; 
          final String b = "hello";  
          String d = "hello";
          String c = b + 2;   //如同宏变量一样，在编译期就指向常量池的同个值，所以相等
          String e = d + 2;   //没有调用intern，所以不相等
          System.out.println((a == c));
          System.out.println((a == e));
      }
  }
  //true
  //false
  ```

  3. 用final来“防止”不小心修改变量是不恰当的。（java的基本类型是值传递）

## static+final

static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！

 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。

 对于方法，表示不可覆盖，并且可以通过类名直接访问。

！特别对于容器类型如List，可以修改里面的内容但是不能修改本身

## volatile

- 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写
  入。
- 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不
  具有原子性。

保证可见性的两个方式：

1. 立即写回：操作后立即从缓存中把数据写回主存
2. 嗅探总线通知：其他线程和处理器会通过嗅探总线监测自己缓存的数据是否过期。数据操作后也会立刻通知。

## default

菜鸟教程：**目的是为了解决接口的修改与现有的实现不兼容的问题。**

比如接口A，示例B实现了接口A，但是现在接口A要新增一个方法，为了不影响B的编译，就设置A的这个新方法为default，那么B就会默认实现了这个方法而不用自己再去实现。

## transient

java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就**不会序列化**到指定的目的地中