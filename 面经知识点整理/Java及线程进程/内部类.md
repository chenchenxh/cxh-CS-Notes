## 内部类

四类：成员内部类、局部内部类、匿名内部类、静态内部类

性质：

- **匿名内部类**是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

- **成员内部类**可以无条件访问外部类的成员。编译器会默认为成员内部类添加了一个指向外部类对象的引用

- **局部内部类和匿名内部类**只能访问final变量。（因为匿名内部类在编译阶段就会对局部变量进行复制，但是如果编译阶段无法确定，就会通过构造器传参的方式初始化。也就是说例如变量a，会有两份a。**所以就会造成数据不一致！**因此java为了解决这个问题则让**变量限制为只能是final变量**
- **静态内部类**是不持有外部类的引用的。而且静态内部类可以单独初始化而不需要外部类先初始化。



！可以看看[链接](https://www.cnblogs.com/dolphin0520/p/3811445.html)里面的练习题，关于内部类的初始化的问题还有内部变量的访问

- 匿名内部类的两种可能：①定义的是接口；②定义的是抽象方法

## 匿名内部类的内存泄露问题

https://blog.csdn.net/qq_36713816/article/details/74207459

出现原因：匿名内部类会默认持有外部类的引用，如果内部类一直被占用，那么外部类就得不到回收而出现内存泄露。

例如：

Activity中定义一个Handler，而这个handler里面的message又会持有handler的引用，所以如果message得不到处理，那么handler和Activity都得不到回收。

    private Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            // do something 
        }
    };
解决方法：让handler定义为静态内部类，这个类持有外部活动的弱引用即可。

关于内存泄漏还有[这篇文章](https://blog.csdn.net/linyukun6422/article/details/52514447)，通过反编译分析，也提到了集中解决方式

> 解决思路：
>
> 1. 去除隐式引用（通过静态内部类来去除隐式引用）
> 2. 手动管理对象引用（修改静态内部类的构造方式，手动引入其外部类引用）
> 3. 当内存不可用时，不执行不可控代码（Android可以结合智能指针，WeakReference包裹外部类实例）

> 并不是所有的内部类只能使用静态内部类，只有在该内部类中的生命周期不可控制的情况下，我们要采用静态内部类