## JVM的运行时数据区

https://blog.csdn.net/QuinnNorris/article/details/74503168

官方文档的区域：

![img](https://img-blog.csdn.net/20170707184935949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbm5Ob3JyaXM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 程序计数器

程序运行到的字节码的行号，每个线程各自私有。如果是native方法，那么此处为空

### Java虚拟机栈和堆

这两块是Java虚拟机重要的两块知识，具体信息可以看操作系统章节的“栈和堆”

- 栈的结构为栈帧。主要分为局部变量表、操作数栈、动态链接、方法返回地址
- 堆。大部分对象都存储在堆上（随着编译器和虚拟机的发展，一些对象会栈上分配空间）。GC的主要区域
- 本地方法栈。是jvm给native方法调用的一块区域

需要注意的是：StackOverFlow和OutOfMemory的区别。

> 这里的OutOfMemory专指栈的溢出。
>
> StackOverFlow是因为虚拟机给每个线程分配的可迭代的空间最大值，如果迭代层数过多则会报错。
>
> OutOfMemory是整个栈区都已经被分配满了，没有空间分配新的线程了。这种情况相对少见。

另外堆和栈使用的两个概念：

> 栈上分配（Stack Allocation）
>
> java堆中的对相对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾回收机制可以回收堆中不再使用的对象 ，但回收动作无论是从筛选开始还是到回收和整理都耗费时间。如果一个对象被确定不会逃逸出方法之外，那让这个对象在栈上分配是一个不错的想法，对象占用的内存空间就可以随栈帧的出栈而被销毁。
>
> 标量替换（Scalar Replacement）
>
> 标量是指一个数据已经无法再分解成更小的数据来表示了，java虚拟机中的原始数据（int，double…）都是不能再分解的，所以原始数据都是标量。相对应的，如果一个数据可以继续分解，他就是聚合量，比如java中很多对象都是聚合量而不是标量。那么从栈上分配的概念延伸出来，如果一个对象可以在栈上分配，我们可以不在栈上创建这个对象的整体，而是创建这个对象的多个被使用到的变量代替创建对象，即用多个标量来替换创建该聚合量。

### 方法区

线程共有的，存储着已经加载的类信息、静态变量、即时编译器编译后的代码等。

### 运行时常量池

方法区的一部分，存储着常量，如String和int的一部分值，