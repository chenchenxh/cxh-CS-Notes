- Exception继承自Throwable

- 栈轨迹printStackTrace()

- Java标准异常：Throwable。Exception和Error都是继承自Throwable。**Error一般是编译时和系统错误**

  两者使用上都没什么区别，但是一般使用上认为Error是虚拟机相关的如系统崩溃，虚拟机错误等，认为是 **无法恢复的，建议程序终止**。而Exception则是异常，一般是认为是 **可以恢复的，建议捕获并处理**

- 特例：RuntimeException。被称为“不接受检查异常“

## finally

Java已经有垃圾回收，为什么还要finally？用来干什么？

finally是在try-catch块执行结束后 **保证会执行的代码块**，用来处理其他需要关闭和清理的资源：比如文件和网络连接等。



## 异常丢失

异常是一个特别重要的程序出错标志，但是异常会丢失：**以某种特殊的方式使用finally语句**

```java
try{
    try{
        throw new Exception1();
    }finally{
        throw new Exception2();
    }
}catch(Exception e){
    e.printStackTrace();   // 这里会只接收到Exception2
}
```

这就导致了异常1丢失，“前一个异常还没处理就抛出另一个异常”

## 构造器的异常

在finally的时候说到finally可以用来关闭文件或者关闭网络连接，但是如果是打开文件的时候出错，那么这时候去关闭文件就会出问题。

```java
try{
    openFile();
}catch(FileNotFoundException e){
    
}catch(Exception e){
    
}finally{
    closeFile();  //此处在文件未能成功打开的情况，会出问题
}
```

解决办法：使用嵌套的try-catch块

```java
try{
    openFile();
}catch(FileNotFoundException e){
    
}finally{
    try{
        doOtherThings();
    }catch(Exception e){
        
    }finally{
        closeFile();    //在嵌套中关闭文件
    }
}
```

## ！异常的“吞食则有害”

> **异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。**
>
> **实际上，异常处理的一个重要目标就是把错误处理的代码和错误发生的地点相分离**

上面这段话很关键，如果不知道如何处理这个异常，那么就把他throw出去，交给其他调用者去处理。

分离异常处理和代码，是为了 **代码更容易理解和维护**。

下面这类型代码尽可能避免：

```java
try{
    doSomeThing();
}catch(ImportantExcepiton e){
    //捕获了如何啥都不干（或者干了自以为正确的事情，并不给调用者其他空间）
}
```

## 异常说明

>  C++从CLU语言那里带来了一种思想：异常说明。这样子，就可以用编程的方式在方法的特征签名中，证明这个方法将有可能抛出异常。**异常说明可能有两个意思：一个是“我的代码会产生这个异常，这由你来处理”；另一个是“我的代码忽略了这些异常，这由你来处理“**

### “被检查的异常”

*这个概念需要明确：例如上面说到的**RuntimeError就是“不需要检查的异常”**，而其他的异常大部分是“被检查的异常“，也就是说这些异常如果没有被捕获也没有throw，那么编译器会直接报错。*

#### 缺点

作者在书中的”观点“小节中提到，Java借鉴C++的折中”被检查的异常“是一种**尝试**。

从示意程序和小型程序来看，这种“被检查的异常”的好处很明显，但是程序开始变大之后，可能并不是这么理想。

1. 首先这个会导致开发效率的降低
2. 而且这种“未被捕获的异常”，实际上是在“**强迫程序员在不知道该采用什么措施处理程序的时候提供处理程序**”，并说到这是“很不现实的”

####  作者的思考

Java的这种“被检查的异常”的好处其实就是：**编译阶段就报告并强制程序员去处理**

但是其实：

> 1. 程序不在于编译器是否强制程序员去处理错误，而是要有一致的、使用异常来报告错误的模型
> 2. 不在于什么时候进行检查，而是一定要有类型检查。也就是并没必要去强制程序使用正确的类型

作者的观点：

1. **减少编译阶段的约束可以显著提高程序员的编程效率。“放射和泛型”就是用来补偿静态类型检查带来的过多限制。**
2. **期望在编译阶段都指出所有错误是不现实的。其实更重要的是要理解编译器的能力限制（把这部分任务给自动构建过程和单元测试）**

#### 我的思考

对作者的这段讨论的思考：

1. 当前的编译器的快速发展可能确实让人觉得编译器应该越来越完善甚至一个”万能的“检查器。但是其实编译器也只是开发程序过程中的一环而已。**它应该就做好自己的工作，而不是全能**。“期望在编译阶段就指出所有错误是不现实的”
2. 这也就提醒，一个好的程序，应该是配套这一套完善的体系，包括单元测试等方面。

### 处理“被检查的异常”

1. 在main中throw，**把异常交给控制台**
2. 把不知道如何处理的异常放入RuntimeException中重新抛出，这就是一个“不需要被检查的异常”了
3. 也可以直接交给以后的代码去处理。