## RTTI

Runtime Type Identification运行时类型识别

从数组中取出对象的时候，实际上是当做Object持有，但是会自动将结果转型为本来的类，这是RTTI最基本的使用形式。

> 因为在Java中，所有的类型转换都是在运行时进行正确性检查的。

> RTTI类型转换并不彻底：Object被转型为Shape，而不是转型为Circle、Square。这是因为目前我们只知道List<Shape>中保存的是Shape。**在编译时，将由容器和Java的泛型系统来强制确保这一点；而在运行时，由类型转换操作来确保这一点**

作者也提到，这也是多态机制的基本目标。尽可能少了解对象的具体类型，而是和一个通用打交道，更容易阅读和维护。

当然，RTTI在过程中也可以其实可以读取到某个特定物体的类型。



## Class对象

- JVM子系统：类加载器

- 所有的类都是动态加载的，需要使用的时候再加载，而且一个类的各个部分也都是必需的时候才加载。

### 初始化惰性

使用Class.ForName可以获得一个类的引用，这时候是会对这个类进行初始化的。但是如果使用Class c = Iter.class这种的话，是会有“初始化惰性”的

类加载器的过程：加载、链接、初始化

1. 一个static final变量是在初始化之前就分配并初始化的。
2. 一个static final 域还不足以确保这种行为
3. 一个static非final，那么在访问第一次访问时才分配和初始化。

### 泛化的Class对象

普通的Class对象可以被赋值任何Class对象,但是如果加上泛型语法,那么可以强制编译进行类型检查

```java
Class<Integer> genericClass = int.class;
genericClass = float.class;  //编译错误
Class<Number> genericClass2 = int.class; //同样编译错误，虽然Integer继承自Number。
Class<? extends Number> gen2 = int.class;  //使用这种就没有问题
```

作者的这里示例很好地展示了怎么使用泛型来完成（存储class的type，然后更具这个type去转换）：

![3](D:\typora\pic\3.PNG)

## 转型方法

1. (Class)
2. 运行时获得class，然后newInstance或者class.cast()
3. instanceof

## 反射：运行时的类信息

> 人们想要在运行时获取类的信息的一个动机，便是希望提供在跨网络的远程平台上创建和运行对象的能力。这被称为远程方法调用（RMI）

以为上述的方法可以提供一些 **分布能力**，提供这个公共代码的机器就是描述这个类的公共场所。可以通过修改这个类的信息来达到修改分布式下多个代码的能力。

### 反射和RTTI

（这里的RTTI特指“传统的RTTI”）



*网络上对于这个区别的说话有：RTTI实际上是C++的概念。RTTI和反射是两个不同体系在描述同一件事情，RTTI对应C++体系，反射对应OO体系。只不过两者用的是不同的实现方法，相对而言Java的反射更为完整一些。*



反射机制获取的类的class文件对于JVM来说是必须可获取的：不是在本地机器就是在网络上。所以RTTI和反射之间的真正的区别只在于： **对于RTTI来说，编译器在编译时打开和检查class文件。而对于反射机制来说，class文件在编译时是不可获取的，所以是在运行时打开和检查class文件**



## 动态代理

### 1. 代理

比如你希望对一个类进行调用，并度量这些调用的开销，那么这时候就可以使用代理，让代理来完成这些操作，并且可以随时减去。

### 2. 动态代理

使用Java的自带的Proxy函数，以及InvocationHandler接口来完成代理，但是实际代理过程还不是很理解



## 空对象

不仅可以使用null之外，可以通过加入一个空对象来满足其他的一些需求（比如省下检查null的精力）。

可以通过**默认新建空对象来达到这个对象的一些默认行为，防止运行错误**

- **可以通过动态代理来简化初始化的过程**

- 模拟对象和桩

  空对象的逻辑变体是模拟对象和桩

  > 模拟对象和桩之间的差异在于程序不同。模拟对象往往是轻量级和自测试的，通常很多模拟对象被创建是为了处理各种不同的测试情况。桩只是返回桩数据，它通常是重量级的，并且在测试之间反复使用。
  >
  > **桩是一个钟复杂对象，它要做很多事**
  >
  > **对于模拟对象，如果你需要做很多事情，通常会创建大量小而简单的模拟对象**



## 总结

> 面向对象编程语言的目的是让我们在凡是可以使用的地方都使用多态机制，只在必需的地方使用RTTI

> 然而多态机制的方法调用，需要我们拥有对基类定义的**控制权**......如果基类有别人控制，那么RTTI便是一种解决之道

作者举了一个例子，比如Instrument乐器，如果你要在“管弦类”乐器上加一个“清洗”的功能，如果拥有基类乐器的控制权，那么可以在基类中加入PrepareInstrument方法，在实现“管弦类”的时候重写即可。

但是如果没有基类的控制权，那么就在“管弦类”乐器中加入“clearInstrument”方法，然后**通过RTTI运行时检测类型，来实现Instrument到“管弦类”的转化，从而可以成功调用“clearInstrument”方法**。



作者给出的建议是”**尽力编写能够进行静态检查的代码**，但是也不用极力去避免动态类型，因为这也完成功能和完善代码的有力手段“。

原因跟上一章节说的一样，这部分任务应该是交给程序的其他部分验证，而非都是编译器完成。