## 清理
### finalize

既然Java都有垃圾回收了，为什么还要finalize？是用来回收什么东西的吗？

> finalize的需求被java限制到一种特殊情况，即通过某种创建对象以外的方式为对象分配了存储空间。

> 是由于在分配内存的时候采用了类似C语言的做法，而非Java的通常做法。这种情况要发生在使用”本地方法“的情况下。

所以其实finalize用于内存回收的话，是用来操作native类方法的内存的。我觉得finalize的另外一个作用有”这个对象被回收，需要通知其他对象的一些操作，或者对数据进行存储之类“。

- finalize并不是保证一定被调用。

- “终结函数无法预料，常常是危险的，总之是多余的”《Effective Java》

### 必须实施清理

- Java不允许创建局部对象
- 不可以认为垃圾回收器可以完全的替代析构函数，而是还有某个恰当的Java方法来代替完成任务（此处并未说明）
- JVM在面临内存耗尽之前是不会浪费时间去执行垃圾回收的

- 通过System.gc()来强制执行终结动作。（也只是给JVM一个回收建议）

### JIT即时编译《Java虚拟机》

.class字节码文件，编译器会在必要的时候才编译为机器码。

新版JDK的Java HotSpot技术就是类似方法，一个代码被执行则会进行优化，如果执行得越多则速度越快。

（相对于全部编译成机器码，会导致文件增大，页面调度增多）

## 未看：可变参数类型