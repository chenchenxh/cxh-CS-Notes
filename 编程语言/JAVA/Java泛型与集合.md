# 泛型

Java的泛型编程和C++的template很像，用法也很类似。但是也有不同之处。他们是使用方法类似，但是实现方法就有所不同了。

C++一开始引入泛型编程是为了通用性，而这种“多态”其实是对于程序员而言，也就是程序员不知道这个类型是什么，但是在编译之后就知道了（会增加编译器的工作）。**C++中，模板的本质是一套宏指令集，编译器会对没种类型创建一份模板代码的副本。也就是说相同的template示例会共享静态变量**，如MyClass<Foo>不会与MyClass<Bar>共享静态变量。然而，两个MyClass<Foo>实例则会共享静态变量。

Java的泛型编程则是“类型消除”（擦拭法，编译器对泛型一无所知，所有的工作都是编译器完成对T的安全的强制转型），可以使得代码漂亮些简洁些，被称为“语法糖”，因为这对于提升速度和性能并没有什么太大影响。

由于架构设计上的差异，Java泛型和C++模板还有如下很多不同点(https://blog.csdn.net/michellechouu/article/details/47044331):

1. C++模板可以使用int等基本数据类型。Java则不行，必须转而使用Integer

2. Java中，可以将模板的类型参数限定为某种特定类型。例如，你可能会使用泛型实现CardDeck，并规定参数必须扩展自CardGame。

3. C++中，类型参数可以实例化，Java不可以实例化

4. Java中，类型参数（即MyClass<Foo>中的Foo）不能用于静态方法和变量，因为他们会被MyClass<Foo>和MyClass<Bar>共享。但在C++中，这些类是不同的，类型参数可以用于静态方法和静态变量。

5. 在Java中，不管类型参数是什么，MyClass的所有实例都是同一类型。类型参数会在运行时被抹去。而C++中，参数类型不同，实例类型也不同



Java泛型的基本使用方法就不赘述了，主要看几个特殊的点：

1. 静态方法的泛型：静态方法不能直接使用类的泛型，但是可以使用静态方法自己的泛型。比如类使用T，静态方法可以使用K来表示
2. 部分反射API是泛型，这个可以从这些反射的API中看出。



# 集合

数据结构中常用的各种集合工具，如Set，Map，List，Queue，Stack等，这些在Java中都是Collection。具体是使用也和C++的STL库中类似。