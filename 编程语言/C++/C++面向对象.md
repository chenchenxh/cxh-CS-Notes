## C++类相关概念


### 访问修饰符

private、protected、public

### 构造函数&析构函数

```c++
//构造
Line::Line( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
//拷贝构造
Line::Line(const Line &obj)
{
    ...
}
```

类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

```c++
//析构
Line::~Line(void)
{
    cout << "Object is being deleted" << endl;
}
```

### 友元

类的友元函数是定义在类外部，但**有权访问类的所有私有（private）成员和保护（protected）成员**。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数

```c++
class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
//友元类声明：friend class ClassTwo
//即可声明ClassTwo是Box的友元类
```

### 内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要**重新编译函数的所有客户端**，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

**在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符**。

### 类的静态变量static

我们可以使用 **static** 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员放置在类的定义中，但是可以在类的外部通过使用**范围解析运算符 ::**** 来重新声明静态变量从而对它进行初始化

```c++
class Box
{
   public:
      static int objectCount;
	  ...
}
int Box:objectCount = 0;
//调用的时候也用Box::objectCount
```

### 运算符重载

```c++
Box operator+(const Box&); //类的成员函数
Box operator+(const Box&, const Box&);  //非成员函数
```

不可重载的运算符

| ::   | .*   | .    | ?:   |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

### c++多态

**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

使用过程中，就是当子类改写父类的函数时，如果要成功调用子类的重构函数，那么需要将**父类的函数前面加virtual**，如下

```c++
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
//然后Shape的子类就可以改写area函数
```

1. **虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

   我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

2. 纯虚函数

   ```c++
   virtual int area() = 0;
   ```

### 数据隐藏

数据隐藏包括数据封装和数据抽象。

**数据封装**是一种把数据和操作数据的函数捆绑在一起的机制，**数据抽象**是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。

### c++接口（抽象类）

如果类中**至少有一个函数被声明为纯虚函数**，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的

如果A是一个接口，BC继承A并实现A中的纯虚函数，那么BC可以被实例化

**特别注意的是**，如果A是一个接口，BC继承并实现了A中的纯虚函数，此时B可以声明自己的一个纯虚函数，但是这样子的话B就不能实例化，需要再用D继承B，D才可以实例化。**也就是说**，可以声明一个接口继承一个接口。